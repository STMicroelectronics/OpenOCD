# This is a nucleo-h7a3zi with a single STM32H7A3ZIT6Q chip.
# https://www.st.com/en/evaluation-tools/nucleo-h7a3zi-q.html
#

# This is for using the onboard STLINK
source [find interface/stlink.cfg]

transport select hla_swd

set CHIPNAME stm32h7a3zit6q

# enable stmqspi
if {![info exists OCTOSPI]} {
	set OCTOSPI1 1
	set OCTOSPI2 0
}

source [find target/stm32h7x_dual_bank.cfg]

# OCTOSPI initialization
# qpi: 4-line mode
proc octospi_init { qpi } {
	global a
	mmw 0x58024540 0x000007FF 0				;# RCC_AHB4ENR |= GPIOAEN-GPIOKEN (enable clocks)
	mmw 0x58024534 0x00284000 0				;# RCC_AHB3ENR |= IOMNGREN, OSPI2EN, OSPI1EN (enable clocks)
	sleep 1									;# Wait for clock startup

	mww 0x5200B404 0x03010101				;# OCTOSPIM_P1CR: assign Port 1 to OCTOSPI1
	mww 0x5200B408 0x00000000				;# OCTOSPIM_P2CR: disable Port 2

	# PB10: BK1_NCS, PB02: CLK, PD13: BK1_IO3, PE02: BK1_IO2, PD12: BK1_IO1, PD11: BK1_IO0,
	# PC11: BK2_NCS, PE10: BK2_IO3, PD06: BK2_IO2, PE08: BK2_IO1, PE07: BK2_IO0

	# PB10:AF09:V, PB02:AF09:V, PC11:AF09:V, PD13:AF09:V, PD12:AF09:V, PD11:AF09:V
	# PD06:AF10:V, PE10:AF10:V, PE08:AF10:V, PE07:AF10:V, PE02:AF09:V
	# Port B: PB10:AF09:V, PB02:AF09:V
	mmw 0x58020400 0x00200020 0x00100010	;# MODER
	mmw 0x58020408 0x00300030 0x00000000	;# OSPEEDR
	mmw 0x5802040C 0x00000000 0x00300030	;# PUPDR
	mmw 0x58020420 0x00000900 0x00000600	;# AFRL
	mmw 0x58020424 0x00000900 0x00000600	;# AFRH
	# Port C: PC11:AF09:V
	mmw 0x58020800 0x00800000 0x00400000	;# MODER
	mmw 0x58020808 0x00C00000 0x00000000	;# OSPEEDR
	mmw 0x5802080C 0x00000000 0x00C00000	;# PUPDR
	mmw 0x58020824 0x00009000 0x00006000	;# AFRH
	# Port D: PD13:AF09:V, PD12:AF09:V, PD11:AF09:V, PD06:AF10:V
	mmw 0x58020C00 0x0A802000 0x05401000	;# MODER
	mmw 0x58020C08 0x0FC03000 0x00000000	;# OSPEEDR
	mmw 0x58020C0C 0x00000000 0x0FC03000	;# PUPDR
	mmw 0x58020C20 0x0A000000 0x05000000	;# AFRL
	mmw 0x58020C24 0x00999000 0x00666000	;# AFRH
	# Port E: PE10:AF10:V, PE08:AF10:V, PE07:AF10:V, PE02:AF09:V
	mmw 0x58021000 0x00228020 0x00114010	;# MODER
	mmw 0x58021008 0x0033C030 0x00000000	;# OSPEEDR
	mmw 0x5802100C 0x00000000 0x0033C030	;# PUPDR
	mmw 0x58021020 0xA0000900 0x50000600	;# AFRL
	mmw 0x58021024 0x00000A0A 0x00000505	;# AFRH

	# OCTOSPI1: memory-mapped read mode with 4-byte addresses
	mww 0x52005130 0x00001000				;# OCTOSPI_LPTR: deactivate CS after 4096 clocks when FIFO is full
	mww 0x52005000 0x00400048				;# OCTOSPI_CR: FMODE=0x0, APMS=1, FTHRES=0, FSEL=0, DQM=1, TCEN=1
	mww 0x52005008 0x00190100				;# OCTOSPI_DCR1: MTYP=0x0, FSIZE=0x19, CSHT=0x01, CKMODE=0
	mww 0x5200500C 0x00000003				;# OCTOSPI_DCR2: PRESCALER=3
	mww 0x52005108 0x00000000				;# OCTOSPI_TCR: SSHIFT=0, DCYC=0x0
	mmw 0x52005000 0x00000001 0				;# OCTOSPI_CR: EN=1

	# OCTOSPI2: memory-mapped read mode with 4-byte addresses
	mww 0x5200A130 0x00001000				;# OCTOSPI_LPTR: deactivate CS after 4096 clocks when FIFO is full
	mww 0x5200A000 0x00400048				;# OCTOSPI_CR: FMODE=0x0, APMS=1, FTHRES=0, FSEL=0, DQM=1, TCEN=1
	mww 0x5200A008 0x00190100				;# OCTOSPI_DCR1: MTYP=0x0, FSIZE=0x19, CSHT=0x01, CKMODE=0
	mww 0x5200A00C 0x00000003				;# OCTOSPI_DCR2: PRESCALER=3
	mww 0x5200A108 0x00000000				;# OCTOSPI_TCR: SSHIFT=0, DCYC=0x0
	mmw 0x5200A000 0x00000001 0				;# OCTOSPI_CR: EN=1

	if { $qpi == 1 } {
		# Enter 4-Byte mode
		mww 0x52005100 0x00003001			;# OCTOSPI_CCR: DMODE=0x0, ABMODE=0x0, ADSIZE=0x3, ADMODE=0x0, ISIZE=0x0, IMODE=0x1
		mww 0x52005110 0x000000B7			;# OCTOSPI_IR: Enter 4-Byte mode
		sleep 1

		# Enter QPI mode
		mww 0x52005100 0x00003001			;# OCTOSPI_CCR: DMODE=0x0, ABMODE=0x0, ADSIZE=0x3, ADMODE=0x0, ISIZE=0x0, IMODE=0x1
		mww 0x52005110 0x00000038			;# OCTOSPI_IR: Enter QPI
		sleep 1

		# memory-mapped fast read mode with 4-byte addresses and 2 dummy cycles (for read only)
		mww 0x52005000 0x30400049			;# OCTOSPI_CR: FMODE=0x3, APMS=1, FTHRES=0, FSEL=0, DQM=1, TCEN=1
		mww 0x52005100 0x03003303			;# OCTOSPI_CCR: DMODE=0x3, ABMODE=0x0, ADSIZE=0x3, ADMODE=0x3, ISIZE=0x0, IMODE=0x3
		mww 0x52005108 0x00000002			;# OCTOSPI_TCR: SSHIFT=0, DCYC=0x2
		mww 0x52005110 0x0000000B			;# OCTOSPI_IR: FAST_READ

		mww 0x5200A100 0x00003001			;# OCTOSPI_CCR: DMODE=0x0, ABMODE=0x0, ADSIZE=0x3, ADMODE=0x0, ISIZE=0x0, IMODE=0x1
		mww 0x5200A110 0x00000038			;# OCTOSPI_IR: Enter QPI
		sleep 1

		# memory-mapped fast read mode with 4-byte addresses and 2 dummy cycles (for read only)
		mww 0x5200A000 0x30400049			;# OCTOSPI_CR: FMODE=0x3, APMS=1, FTHRES=0, FSEL=0, DQM=1, TCEN=1
		mww 0x5200A100 0x03003303			;# OCTOSPI_CCR: DMODE=0x3, ABMODE=0x0, ADSIZE=0x3, ADMODE=0x3, ISIZE=0x0, IMODE=0x3
		mww 0x5200A108 0x00000002			;# OCTOSPI_TCR: SSHIFT=0, DCYC=0x2
		mww 0x5200A110 0x0000000B			;# OCTOSPI_IR: FAST_READ

		# as OCTOSPI is set to instruction/address/data on 4 lines in memory mapped mode, driver will *always*
		# use this setting (i. e. for probe, erase, write)
		# the 'Enter QPI mode' command is chip specific, additionally both w25q128fv must be configured in advance by
		# programming the *NON*-volatile QE bit (bit 1 in status register 2), e. g. by the following commands
		#
		# stmqspi cmd $b 0 0x06
		# stmqspi cmd $b 0 0x31 0x02 0x02
		# stmqspi cmd $b 2 0x35
		#
		# the last one should return  '-> 02 02' to indicate successful setting of QE bit
		# furthermore, the flash chip changes its id from 0x1940ef to 0x1960ef upon entering QPI mode
	} else {
		# Enter 4-Byte mode
		mww 0x52005100 0x00003001				;# OCTOSPI_CCR: DMODE=0x0, ABMODE=0x0, ADSIZE=0x3, ADMODE=0x0, ISIZE=0x0, IMODE=0x1
		mww 0x52005110 0x000000B7				;# OCTOSPI_IR: Enter 4-Byte mode
		sleep 1

		# memory-mapped read mode with 4-byte addresses
		mww 0x52005000 0x30400049				;# OCTOSPI_CR: FMODE=0x0, APMS=1, FTHRES=0, FSEL=0, DQM=1, TCEN=1
		mww 0x52005100 0x01003101				;# OCTOSPI_CCR: DMODE=0x1, ABMODE=0x0, ADSIZE=0x3, ADMODE=0x1, ISIZE=0x0, IMODE=0x1
		mww 0x52005110 0x00000003				;# OCTOSPI_IR: READ

		# memory-mapped read mode with 4-byte addresses
		mww 0x5200A000 0x30400049				;# OCTOSPI_CR: FMODE=0x0, APMS=1, FTHRES=0, FSEL=0, DQM=1, TCEN=1
		mww 0x5200A100 0x01003101				;# OCTOSPI_CCR: DMODE=0x1, ABMODE=0x0, ADSIZE=0x3, ADMODE=0x1, ISIZE=0x0, IMODE=0x1
		mww 0x5200A110 0x00000003				;# OCTOSPI_IR: READ
	}
}

$_CHIPNAME.cpu0 configure -event reset-init {
	global OCTOSPI1
	global OCTOSPI2

	mww 0x52002000 0x00000034				;# FLASH_ACR: 4 WS for 192 MHZ HCLK

	mmw 0x58024400 0x00000001 0x00000018	;# RCC_CR: HSIDIV=1, HSI on
	mmw 0x58024410 0x10000000 0xEE000007	;# RCC_CFGR: MCO2=system, MCO2PRE=8, HSI as system clock
	mww 0x58024418 0x00000040				;# RCC_D1CFGR: D1CPRE=1, D1PPRE=2, HPRE=1
	mww 0x5802441C 0x00000440				;# RCC_D2CFGR: D2PPRE2=2, D2PPRE1=2
	mww 0x58024420 0x00000040				;# RCC_D3CFGR: D3PPRE=2
	mww 0x58024428 0x00000040				;# RCC_PPLCKSELR: DIVM3=0, DIVM2=0, DIVM1=4, PLLSRC=HSI
	mmw 0x5802442C 0x0001000C 0x00000002	;# RCC_PLLCFGR: PLL1RGE=8MHz to 16MHz, PLL1VCOSEL=wide
	mww 0x58024430 0x01070217				;# RCC_PLL1DIVR: 192 MHz: DIVR1=2, DIVQ=8, DIVP1=2, DIVN1=24
	mmw 0x58024400 0x01000000 0				;# RCC_CR: PLL1ON=1
	sleep 1
	mmw 0x58024410 0x00000003 0				;# RCC_CFGR: PLL1 as system clock
	sleep 1

	adapter speed 24000

	if { $OCTOSPI1 } {
		octospi_init 1
	}
}

